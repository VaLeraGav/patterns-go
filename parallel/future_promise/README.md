# Обещание (Future/Promise)

Паттерн `Future/Promise` позволяет асинхронно выполнять задачи и получать результат в будущем. В Go этот паттерн можно реализовать с использованием горутин и каналов. Мы можем создать структуру, которая будет представлять промис и предоставлять методы для ожидания результата.

- **Promise** — обещание предоставить результат операции в будущем. Оно используется для запуска задачи и получения объекта, который будет хранить результат выполнения задачи (он же async).

- **Future** — это объект, который позволяет проверять готовность результата и извлекать его, когда он будет доступен (он же await).

```go
// Запускаем задачу через Promise
future := Promise(func() (int, error) {
    time.Sleep(1 * time.Second)
    return 0, nil
})

fmt.Println("Задача запущена, можно делать что-то еще...")

// Ожидаем результат
result := <-future
if result.err != nil {
    fmt.Println("Ошибка:", result.err)
} else {
    fmt.Println("Результат:", result.value)
}
```

В этом примере задача запускается в фоне и ты можешь делать что-то еще, пока она не выполнится. Дальше ты получаешь результат через канал, который выступает в роли `future`. Как только задача завершилась, результат становится доступен, и программа продолжает свое выполнение.

Этот подход удобен тем, что позволяет избежать блокировки основного потока выполнения, особенно если задача требует длительного времени. Ты просто запускаешь задачу, делаешь другие вещи, а затем, когда задача завершена, возвращаешься к ее результату.
