# Декоратор (Decorator)

Паттерн `Decorator` относится к структурным паттернам уровня объекта.

Паттерн `Decorator` используется для расширения функциональности объектов путем динамического добавления объекту новых возможностей. При реализации паттерна используется отношение композиции.

Сущность работы декоратора заключается в обёртывании готового объекта новым функционалом, при этом весь оригинальный интерфейс объекта остается доступным, путем передачи декоратором всех запросов обернутому объекту.

Требуется для реализации:

- Базовый абстрактный класс `Component` который предоставляет интерфейс для класса декоратора и компонента

```go
type Component interface {
	Operation() string
}

```

- Класс `ConcreteDecorator`, реализующий интерфейс `Component` и перезагружающий все методы компонента, по необходимости к ним добавляется функционал

```go
func NewConcreteComponent(message string) *ConcreteComponent {
	return &ConcreteComponent{message: message}
}

// Operation returns the message.
func (c *ConcreteComponent) Operation() string {
	return c.message
}
```

- `BaseDecorator` может содержать общую логику, которую могут использовать все декораторы. Например, если все декораторы должны хранить ссылку на базовый компонент и реализовывать метод Operation, то эту логику можно вынести в `BaseDecorator`, чтобы избежать дублирования кода. Его использование позволяет легко добавлять новые декораторы, которые могут использовать ту же структуру. Если же вы хотите сделать код проще и не планируете добавлять много декораторов, можно обойтись и без него.

- Класс `ConcreteComponent` реализующий интерфейс `Component` и который будет обернут декоратором.

```go
type UpperCaseDecorator struct {
	BaseDecorator
}

func NewUpperCaseDecorator(component Component) *UpperCaseDecorator {
	return &UpperCaseDecorator{BaseDecorator: *NewBaseDecorator(component)}
}

func (d *UpperCaseDecorator) Operation() string {
	return strings.ToUpper(d.component.Operation())
}
```

При такой структуре нам не важно является ли компонент декоратором или конкретной реализацией, так как интерфейс у них совпадает, и мы можем делать цепочки декораторов. Тем самым динамически менять состояние и поведение объекта.
